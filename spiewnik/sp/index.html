<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Przeglądarka Dokumentów SVG</title>
    <!-- Ładowanie Tailwind CSS dla stylizacji -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Ustawienie czcionki Inter */
        html { font-family: 'Inter', sans-serif; }
        
        /* Usunięcie marginesów i paddingów z HTML/BODY */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-x: hidden; /* Zapobieganie poziomemu scrollowaniu */
        }

        /* Usunięcie domyślnego tła i marginesów z BODY */
        body {
            background-color: #f9fafb;
        }
        
        /* Styl dla kontenera SVG (ramka, cień, margines) */
        #svg-container {
            /* Nowe style dla wizualnego odseparowania strony SVG */
            padding: 1rem; /* Margines wokół strony */
            background-color: #ffffff; /* Białe tło wewnątrz ramki */
            margin: 1rem; /* Zewnętrzny margines od krawędzi okna */
            border-radius: 0.5rem; /* Zaokrąglone rogi */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* Delikatny cień */
            
            min-height: 80vh; 
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        
        #viewer {
            width: 100%; /* Wymuszenie szerokości 100% dla fit-to-width */
            height: auto;
            border-radius: 0; 
            box-shadow: none; 
            margin: 0; 
        }
        
        /* Styl dla minimalistycznych linków stron */
        .page-link-compact {
            display: inline-block;
            margin: 0 0.5rem 0.5rem 0; 
            white-space: nowrap;
        }

        /* Nowy styl dla aktywnego linku */
        .page-link-compact.active {
            font-weight: bold;
            color: #1d4ed8; /* blue-700 */
            text-decoration: underline;
        }

        /* Styl dla nagłówków/kontroli */
        .control-panel {
            padding: 1rem 0;
            background-color: #ffffff; 
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- Główny kontener zajmuje teraz całą dostępną przestrzeń -->
    <main class="w-full min-h-screen">
        
        <!-- INDEKS STRON -->
        <div class="control-panel border-b border-gray-200">
             <div class="mx-auto px-4 max-w-7xl">
                <h2 class="text-xl font-semibold mb-2 text-blue-600">Indeks Stron</h2>
                <div id="page-links" class="text-left mb-2 pb-2 max-h-40 overflow-y-auto">
                    <!-- Tutaj JS wygeneruje minimalistyczne linki do stron -->
                    <div class="text-gray-400">Ładowanie linków...</div>
                </div>
             </div>
        </div>

        <div id="status-message" class="mx-auto px-4 mt-4 p-3 text-sm rounded-lg bg-yellow-100 text-yellow-800 hidden max-w-7xl"></div>


        <!-- PAGINACJA -->
        <div class="control-panel border-b border-gray-200">
            <div id="pagination-controls" class="text-center mx-auto max-w-7xl px-4 hidden">
                <h1 class="text-3xl font-bold flex justify-center items-center space-x-6 p-2">
                    <!-- Link do poprzedniej strony -->
                    <a href="#" id="prev-page-link" class="text-blue-600 hover:text-blue-800 transition duration-150 p-2 rounded-md hover:bg-blue-200 disabled:opacity-50 disabled:pointer-events-none" aria-label="Poprzednia strona">[ &lt; ]</a>
                    
                    <!-- Aktualna etykieta strony -->
                    <span id="current-page-label" class="text-gray-700 font-mono w-24"></span>
                    
                    <!-- Link do następnej strony -->
                    <a href="#" id="next-page-link" class="text-blue-600 hover:text-blue-800 transition duration-150 p-2 rounded-md hover:bg-blue-200 disabled:opacity-50 disabled:pointer-events-none" aria-label="Następna strona">[ &gt; ]</a>
                </h1>
            </div>
        </div>

        <!-- KONTENER SVG (Full Bleed z ramką) -->
        <div id="svg-container">
            <img id="viewer" src="" alt="Wyświetlana strona SVG" class="hidden">
            <p id="initial-message" class="text-gray-400 p-8">Wybierz stronę z indeksu lub użyj linku z hashem w URL, aby rozpocząć przeglądanie.</p>
        </div>
        
    </main>

    <script>
        // Globalne zmienne na dane z JSON
        let dests = {};
        let pages = {};
        // Nowe struktury do paginacji
        let pageLabelsOrder = []; // Posortowana lista etykiet SVG (np. ['lxxxi', '1', '2', ...])
        let labelToPhysicalPage = {}; // Mapa: etykieta SVG -> numer strony fizycznej (np. '1' -> '91')
        let pageLabelToDestName = {}; // Mapa: etykieta SVG -> pełna destynacja 'page.X' (np. '1' -> 'page.91')

        // Ścieżki do plików JSON - ZMIENIONE NA RELATYWNE
        const DEST_PATH = 'dests.json';
        const PAGES_PATH = 'pages.json';

        // Elementy DOM
        const pageLinksContainer = document.getElementById('page-links');
        const viewerImage = document.getElementById('viewer');
        const initialMessage = document.getElementById('initial-message');
        const statusMessage = document.getElementById('status-message');
        const paginationControls = document.getElementById('pagination-controls');
        const prevPageLink = document.getElementById('prev-page-link');
        const nextPageLink = document.getElementById('next-page-link');
        const currentPageLabelSpan = document.getElementById('current-page-label');
        

        /**
         * Funkcja pomocnicza do wyświetlania komunikatów o błędach/statusie
         */
        function displayStatus(message, isError = false) {
            statusMessage.textContent = message;
            statusMessage.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800');
            if (isError) {
                statusMessage.classList.add('bg-red-100', 'text-red-800');
            } else {
                statusMessage.classList.add('bg-yellow-100', 'text-yellow-800');
            }
            statusMessage.classList.remove('hidden');
        }

        /**
         * Pobiera dane JSON. Używa prostej funkcji retry z opóźnieniem.
         */
        async function fetchJsonWithRetry(url, maxRetries = 3, delay = 500) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status} dla ${url}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error(`Błąd ładowania ${url} (próba ${i + 1}/${maxRetries}):`, error.message);
                    if (i === maxRetries - 1) {
                        throw new Error(`Nie udało się załadować ${url} po ${maxRetries} próbach. Sprawdź ścieżkę i serwer.`);
                    }
                    await new Promise(resolve => setTimeout(resolve, delay * (i + 1))); 
                }
            }
        }

        /**
         * Ładuje oba pliki JSON, inicjuje struktury pomocnicze i renderuje linki.
         */
        async function loadDataAndInit() {
            try {
                displayStatus('Ładowanie danych konfiguracji...');
                [dests, pages] = await Promise.all([
                    fetchJsonWithRetry(DEST_PATH),
                    fetchJsonWithRetry(PAGES_PATH)
                ]);
                
                // 1. Inicjalizacja pomocniczych struktur do paginacji
                const physicalPageNumbers = Object.keys(pages).map(Number).sort((a, b) => a - b);
                pageLabelsOrder = physicalPageNumbers.map(num => pages[num.toString()]).filter(label => label);
                labelToPhysicalPage = {};
                pageLabelToDestName = {};

                physicalPageNumbers.forEach(num => {
                    const label = pages[num.toString()];
                    if (label) {
                        labelToPhysicalPage[label] = num.toString();
                    }
                });

                // Mapowanie etykiety SVG na destynację 'page.X' (potrzebne do paginacji)
                Object.keys(dests).forEach(key => {
                    if (key.startsWith('page.')) {
                        const physicalPage = dests[key].page.toString();
                        const pageLabel = pages[physicalPage];
                        
                        if (pageLabel && !pageLabelToDestName[pageLabel]) {
                            // Używamy tylko pierwszego napotkanego 'page.X' dla danej etykiety jako linku nawigacyjnego
                            pageLabelToDestName[pageLabel] = key;
                        }
                    }
                });
                
                // 2. Renderowanie minimalistycznych linków
                renderPageLinks();
                
                // 3. Obsługa bieżącego hasha
                handleHashChange();

                statusMessage.classList.add('hidden');

            } catch (error) {
                console.error("Krytyczny błąd inicjalizacji:", error);
                pageLinksContainer.innerHTML = '<p class="text-red-500">Nie udało się załadować danych. Sprawdź konsolę.</p>';
                displayStatus(`Błąd inicjalizacji: ${error.message}`, true);
                viewerImage.classList.add('hidden');
                initialMessage.classList.remove('hidden');
            }
        }

        /**
         * Generuje minimalistyczną listę linków do stron w panelu bocznym.
         * Wyróżnia aktywny link.
         */
        function renderPageLinks(activePageLabel = null) {
            pageLinksContainer.innerHTML = ''; 

            if (pageLabelsOrder.length === 0) {
                 pageLinksContainer.innerHTML = '<p class="text-red-500">Brak etykiet stron do wyświetlenia.</p>';
                 return;
            }
            
            // Budowa zwięzłego akapitu linków
            const linkFragment = document.createDocumentFragment();

            pageLabelsOrder.forEach(label => {
                const destKey = pageLabelToDestName[label];

                if (destKey) {
                    const a = document.createElement('a');
                    a.href = `#${destKey}`; 
                    a.textContent = label; 
                    
                    let classes = 'text-blue-600 hover:text-blue-800 hover:underline transition duration-150 page-link-compact';
                    
                    // Wyróżnienie aktywnej strony
                    if (label === activePageLabel) {
                        classes += ' active'; // Dodanie nowej klasy CSS
                    }

                    a.className = classes;
                    a.setAttribute('data-page-label', label); // Dodanie atrybutu do łatwego znajdowania linku
                    linkFragment.appendChild(a);
                }
            });

            const p = document.createElement('p');
            p.className = 'text-sm flex flex-wrap';
            p.appendChild(linkFragment);
            pageLinksContainer.appendChild(p);
        }

        /**
         * Obsługuje zmianę hasha URL (lokalnego linku), ładuje SVG i aktualizuje paginację.
         */
        function handleHashChange() {
            const hash = window.location.hash;

            if (!hash || hash === '#') {
                viewerImage.classList.add('hidden');
                initialMessage.classList.remove('hidden');
                paginationControls.classList.add('hidden');
                document.title = 'Przeglądarka Dokumentów SVG';
                renderPageLinks(null); // Odświeżenie bez aktywnego linku
                return;
            }

            const destName = hash.slice(1);
            const dest = dests[destName];

            if (!dest) {
                console.warn(`Destynacja "${destName}" nie została znaleziona w dests.json.`);
                displayStatus(`Błąd: Destynacja "${destName}" nieznana.`, true);
                viewerImage.classList.add('hidden');
                initialMessage.classList.remove('hidden');
                paginationControls.classList.add('hidden');
                renderPageLinks(null); // Odświeżenie bez aktywnego linku
                return;
            }
            
            try {
                const physicalPage = dest.page.toString();
                const pageLabel = pages[physicalPage];
                
                if (!pageLabel) {
                    throw new Error(`Brak etykiety dla strony fizycznej nr ${physicalPage} w pages.json.`);
                }
                
                // 1. Wyróżnienie aktywnego linku
                renderPageLinks(pageLabel);

                // ZMIENIONO: ścieżka SVG jest teraz relatywna
                const svgPath = `${pageLabel}.svg`;

                // 2. Wyświetlenie SVG
                viewerImage.src = svgPath;
                viewerImage.classList.remove('hidden');
                initialMessage.classList.add('hidden');
                
                // 3. Aktualizacja tytułu 
                document.title = `Strona ${pageLabel} (${destName})`;

                // 4. Logika Paginacji
                const currentIndex = pageLabelsOrder.indexOf(pageLabel);
                
                if (currentIndex !== -1) {
                    // Strona jest częścią posortowanej sekwencji (pageLabelsOrder)
                    paginationControls.classList.remove('hidden');
                    currentPageLabelSpan.textContent = pageLabel;

                    // Funkcja pomocnicza do ustawiania linków
                    const updateLink = (linkElement, label) => {
                        if (label) {
                            const destKey = pageLabelToDestName[label];
                            if (destKey) {
                                linkElement.href = `#${destKey}`;
                                linkElement.classList.remove('opacity-50', 'pointer-events-none');
                                linkElement.classList.add('hover:bg-blue-200');
                            } else {
                                linkElement.href = '#';
                                linkElement.classList.add('opacity-50', 'pointer-events-none');
                                linkElement.classList.remove('hover:bg-blue-200');
                            }
                        } else {
                            linkElement.href = '#';
                            linkElement.classList.add('opacity-50', 'pointer-events-none');
                            linkElement.classList.remove('hover:bg-blue-200');
                        }
                    };

                    // Ustawienie linków
                    updateLink(prevPageLink, pageLabelsOrder[currentIndex - 1]);
                    updateLink(nextPageLink, pageLabelsOrder[currentIndex + 1]);
                    
                } else {
                    // Ukryj kontrolki dla destynacji, które nie są częścią głównej sekwencji stron
                    paginationControls.classList.add('hidden');
                }

                // 5. Obsługa błędu ładowania SVG
                viewerImage.onerror = () => {
                    displayStatus(`Błąd ładowania pliku SVG: ${svgPath}. Sprawdź, czy plik istnieje.`, true);
                    viewerImage.classList.add('hidden');
                    initialMessage.classList.remove('hidden');
                };

            } catch (error) {
                console.error("Błąd przetwarzania hasha:", error);
                displayStatus(`Błąd przetwarzania: ${error.message}`, true);
                viewerImage.classList.add('hidden');
                initialMessage.classList.remove('hidden');
                paginationControls.classList.add('hidden');
                renderPageLinks(null); // Odświeżenie bez aktywnego linku
            }
        }

        // Uruchomienie ładowania danych po załadowaniu DOM
        document.addEventListener('DOMContentLoaded', loadDataAndInit);

        // Ustawienie nasłuchiwania na zmianę hasha URL
        window.addEventListener('hashchange', handleHashChange);
    </script>
</body>
</html>

